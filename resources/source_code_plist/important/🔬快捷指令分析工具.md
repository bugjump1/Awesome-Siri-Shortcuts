# 🔬快捷指令分析工具.shortcut

## 快捷指令信息

快捷指令：🔬快捷指令分析工具
动作数量：125
文件大小：282 KB

Glyph 编号 : 59771
Glyph 颜色 : 463140863

快捷指令类型 : 

WatchKit
ActionExtension

## 依赖 :

- 
- 
- 🔬快捷指令分析工具

## URLs :



## 动作列表 : 

```
1: 词典
2: 设定变量 (sc)
3: 设定变量 (action_names)
4: 设定变量 (action_paras)
5: 设定变量 (var_ahead)
6: 设定变量 (var_behind)
7: 获取设备的详细信息 (Device Model)
8: 设定变量 (device)
9: 计数
10: 如果 (4 )
11: 从菜单中选取
12 (11, ): 从菜单中选取 (✳️选择快捷指令)
13: 获取我的快捷指令
14: 从列表中选取 (Q: "选择要分析的快捷指令", Select One)
15: 设定变量 (file)
16 (11, ): 从菜单中选取 (📃选择文件)
17: 获取文件
18: 设定变量 (file)
19 (11, ): 从菜单中选取
20 (10, 4 ): 如果
21: 设定变量 (file)
22 (10, 4 ): 如果
23: 获取文件的详细信息 (File Size)
24: 设定变量 (file_size)
25: 获取文件的详细信息 (Name)
26: 设定变量 (sc_name)
27: 获取文件的详细信息 (File Extension)
28: 设定变量 (file_ext)
29: 如果 (99 shortcut)
30: 从输入中获取图像
31: 调整图像大小 (100 x Auto)
32: Base64 编码
33: 设定变量 (icon_base64)
34: 设定名称 (⊲**sc_name**⊳.plist, without File Extension)
35: 设定变量 (file)
36 (29, 99 short...): 如果
37 (29, 99 short...): 如果
38: 从输入中获取文本
39: 词典
40: 设定变量 (plist_escape)
41: 文本 (⏎var wflowVariableTranslations = {⏎  "ActionOutput": "OutputName",⏎  "Ask": "Ask when Run",⏎  "Clipboard": "Get Clipboard",⏎  "CurrentDate": "Current Date",⏎  "ExtensionInput": "Workflow Input",⏎  "Variable": "VariableName"⏎};⏎//function cl(...o) {⏎  //console.log(JSON.stringify(o, null, 2));⏎//}⏎function parseFormat(format, params) {⏎  var res = params[format.condition];⏎  if (!res)⏎    return format.empty || format.default;⏎  res = format.cases[res] || format.default;⏎  if (typeof res !== "string")⏎    return parseFormat(res, params);⏎  return res;⏎}⏎function getFirstNotNull(ar, def) {⏎  if (!Array.isArray(ar))⏎    throw "getFirstNotNull should be called with an array!";⏎  var l = ar.length;⏎  if (l < 1)⏎    throw "getFirstNotNull should be called with an array with at least one element!";⏎  for (var i = 0; i < l; i++)⏎    if ("undefined" !== typeof ar[i])⏎return ar[i];⏎  return "undefined" !== typeof def ? def : ar[l - 1];⏎}⏎function getAggrandizement(o) {⏎  //cl("aggrandizement", o);⏎  if (!o || !o.Aggrandizements || !o.Aggrandizements.length) {⏎    return "";⏎  }⏎  var agg = o.Aggrandizements;⏎  for (var i = 0; i < agg.length; i++)⏎  if (agg[i].Type === "WFPropertyVariableAggrandizement")⏎    return "|" + agg[i].PropertyName;⏎  else if(agg[i].Type === "WFDictionaryValueVariableAggrandizement")⏎    return "|" + agg[i].DictionaryKey;⏎  ⏎  //cl(agg);⏎  return "";⏎}⏎function getWflowVariableName(dict) {⏎  return "undefined" !== typeof dict["Type"] ? variableOpeningChar +  getFirstNotNull([ dict[wflowVariableTranslations[dict["Type"]]], wflowVariableTranslations[dict["Type"]], dict["Type"] ]) + getAggrandizement(dict) + variableClosingChar : dict;⏎}⏎function roundNumber(num, scale) {⏎  if(!("" + num).includes("e")) {⏎    return +(Math.round(num + "e+" + scale) + "e-" + scale);⏎  } else {⏎    var arr = ("" + num).split("e");⏎    var sig = "";⏎    if(+arr[1] + scale > 0) {⏎      sig = "+";⏎    }⏎    return +(Math.round(+arr[0] + "e" + sig + (+arr[1] + scale)) + "e-" + scale);⏎  }⏎}⏎var formatRegex = /((?!\\\{)\{(?:\\\}|[^\}])+\}|(?:\\\{|[^\{])+)/g;⏎var isNumRegex = /^\s*-?[0-9]+(?:[.,][0-9]+)?\s*$/;⏎var getIndexFromRangeRegex = /^\{(\d+), \d+\}$/;⏎var maxCodeBlockContentLength = deviceModel === "iPad" ? 30 : 10;⏎try {⏎  wflow = PlistParser.parse(wflow.g);⏎  wflow = JSON.parse(JSON.stringify(wflow, null, 0), function (k, v) { return typeof v === "number" || typeof v === "date" ? v.toString() : typeof v === "boolean" ? v ? "1" : "0" : v; });⏎  var result = [],⏎      codeBlocks = [],⏎      codeBlocksId = {⏎   "is.workflow.actions.conditional": true,⏎   "is.workflow.actions.repeat.count": true,⏎   "is.workflow.actions.repeat.each": true,⏎ "is.workflow.actions.choosefrommenu": true⏎};⏎  var actionIndex = 0, codeBlock = "";⏎  wflow.WFWorkflowActions⏎    .forEach(function(action) {⏎    actionIndex++;⏎    codeBlock = "";⏎    var content = "";⏎    var id = action.WFWorkflowActionIdentifier;⏎    var name = getFirstNotNull([actionNamesTranslation[id], id]);⏎    var paramsFromWflow = action.WFWorkflowActionParameters;⏎    var paramsToExtract = allActionParams[id];⏎    var parsedFormat = "";⏎    if (typeof paramsToExtract !== "undefined") {⏎      var format = paramsToExtract.format;⏎      format = (typeof format !== "string") ? parseFormat(format, paramsFromWflow) : format;⏎      var match;⏎      var nVars = 0, failed = 0;⏎      while ((match = formatRegex.exec(format)) != null) {⏎        if (match[0].startsWith("{")) {⏎          nVars++;⏎          var variable = match[0].substring(1, match[0].length - 1);⏎          var list = [];⏎          var parts = variable.split("|");⏎          for (var i = 0; i < parts.length; i++)⏎            if (typeof paramsFromWflow[parts[i].split(":")[0]] !== "undefined")⏎              list.push(parts[i]);⏎          variable = (list.length > 0 ? list[0] : variable.split("|")[0]);⏎          var comma = variable.split(":").length > 1 ? variable.split(":")[1] : 3;⏎          variable = variable.split(":")[0];⏎          content = paramsFromWflow[variable] || paramsToExtract.empty && paramsToExtract.empty[variable];⏎          if (typeof content === "undefined") failed++;⏎          if (isNumRegex.test(content)) content = roundNumber(content, comma).toString();⏎          content = (paramsToExtract.replace && paramsToExtract.replace[variable] && paramsToExtract.replace[variable][content]) || content;⏎          //cl(actionIndex, content);⏎          if (typeof content === "object") {⏎            // (magic) variables are used⏎            switch (content.WFSerializationType) {⏎            case "WFTextTokenAttachment":⏎              content = getWflowVariableName(content.Value);⏎              break;⏎            case "WFTextTokenString":⏎              list = content.Value.string.split("");⏎              var keyList = [];⏎              var abr = content.Value.attachmentsByRange;⏎              Object.keys(abr)⏎                .forEach(function (k) { keyList[parseInt(getIndexFromRangeRegex.exec(k)[1])] = getWflowVariableName(abr[k]); });⏎              if (content.Value.string.includes("\ufffc")) {⏎                content = "";⏎                for (var i = 0; i < list.length; i++) {⏎                  var n = list[i];⏎                  if (n === "\ufffc") {⏎                    while (typeof (n = keyList.shift()) === "undefined" && keyList.length > 0) ;⏎                  }⏎                  content += n;⏎                }⏎              } else {⏎                for (var i = 0; i < keyList.length; i++)⏎                  if (keyList[i])⏎                    list.splice(i, 0, keyList[i]);⏎                content = list.join("");⏎              }⏎              break;⏎            case "WFTimeOffsetValue":⏎              content = content.Value;⏎              content = content.Operation.replace("Add", "+").replace("Subtract", "-") + " " + getWflowVariableName(content.Value) + " " + content.Unit + (parseFloat(content.Value) != 1 ? "s" : "");⏎              break;⏎            case "WFContentPredicateTableTemplate":⏎            case "WFContactFieldValue":⏎            case "WFQuantityFieldValue":⏎              failed++;⏎              break;⏎            default:⏎              failed++;⏎              break;⏎            }⏎          }⏎          parsedFormat += content || "";⏎        } else⏎          parsedFormat += match[0];⏎      }⏎    }⏎    // format done⏎    // save "code blocks" (if, repeat, repeat with each, choose from menu)⏎    codeBlock = "";⏎    if (codeBlocksId[id]) {⏎      var mode = paramsFromWflow.WFControlFlowMode;⏎      if (Array.isArray(name))⏎        name = name[mode];⏎      if (mode == 0) {⏎        codeBlocks.push(actionIndex + ", " + (parsedFormat.length > maxCodeBlockContentLength ? parsedFormat.substr(0, maxCodeBlockContentLength - 2) + "..." : parsedFormat));⏎      } else {⏎        codeBlock = " (" + codeBlocks[codeBlocks.length - 1] + ")";⏎        if (mode == 2)⏎          codeBlocks.pop();⏎      }⏎    }⏎    result.push(actionIndex + codeBlock + ": " + name + (parsedFormat && parsedFormat.length > 0 && failed < nVars ? " (" + parsedFormat.replace(/[\r\n]+/g, "⏎") + ")": ""));⏎  });⏎  result = { list: result };⏎  document.body.appendChild(document.createTextNode(JSON.stringify(result, null, 4)));⏎} catch (ex) {⏎  document.body.appendChild(document.createTextNode(JSON.stringify({ type: ex.name, msg: ex.message, line: ex.line, column: ex.column, sourceURL: ex.sourceURL}, null, 0)));⏎  throw ex;⏎})
42: 设定变量 (script)
43: 文本 (/**⏎ PlistParser: a JavaScript utility to process Plist XML into JSON⏎ @author Todd Gehman (toddgehman@gmail.com)⏎ Copyright (c) 2010 Todd Gehman⏎ --- ⏎ Usage:⏎   var jsonString = PlistParser.parse(xmlString);⏎ ---⏎ ⏎Permission is hereby granted, free of charge, to any person obtaining a copy⏎of this software and associated documentation files (the "Software"), to deal⏎in the Software without restriction, including without limitation the rights⏎to use, copy, modify, merge, publish, distribute, sublicense, and/or sell⏎copies of the Software, and to permit persons to whom the Software is⏎furnished to do so, subject to the following conditions:⏎The above copyright notice and this permission notice shall be included in⏎all copies or substantial portions of the Software.⏎THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR⏎IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,⏎FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE⏎AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER⏎LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,⏎OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN⏎THE SOFTWARE.⏎*/⏎var PlistParser = {};⏎PlistParser.parse = function(plist_xml){⏎  // Special case XML munging if we're running in Appcelerator Titanium⏎  try{⏎    if (typeof Titanium.XML != 'undefined'){⏎      plist_xml = Titanium.XML.parseString(plist_xml);⏎    }⏎  } catch(e){⏎    var parser = new DOMParser();⏎		  plist_xml = parser.parseFromString(plist_xml, 'text/xml');⏎  }⏎    ⏎  var result = this._xml_to_json(plist_xml.getElementsByTagName('plist').item(0));⏎  return result;⏎};⏎PlistParser._xml_to_json = function(xml_node) {⏎  var parser = this;⏎  var parent_node = xml_node;⏎  var parent_node_name = parent_node.nodeName;⏎  // console.log("Working on parent node: ");⏎  // console.log(parent_node);⏎  var child_nodes = [];⏎  for(var i = 0; i < parent_node.childNodes.length; ++i){⏎    var child = parent_node.childNodes.item(i);⏎    if (child.nodeName != '#text'){⏎      child_nodes.push(child);⏎    };⏎  };⏎  ⏎  switch(parent_node_name){⏎    case 'plist':⏎      if (child_nodes.length > 1){⏎        // I'm not actually sure if it is legal to have multiple⏎        // top-level nodes just below <plist>. But I originally ⏎        // wrote it to handle an array of nodes at that level,⏎        // so I'm leaving this handling in for now.⏎        var plist_array = [];⏎        for(var i = 0; i < child_nodes.length; ++i){⏎           plist_array.push(parser._xml_to_json(child_nodes[i]));⏎        };⏎        // var plist_hash = {};⏎        // plist_hash['plist'] = plist_array;⏎        // return plist_hash;⏎        return plist_array;⏎      } else {⏎        // THIS is the standard case. The top-most node under⏎        // <plist> is either a <dict> or an <array>.⏎        return parser._xml_to_json(child_nodes[0]);⏎      }⏎      break;⏎    case 'dict':⏎      var dictionary = {};⏎      var key_name;⏎      var key_value;⏎      for(var i = 0; i < child_nodes.length; ++i){⏎        var child = child_nodes[i];⏎        if (child.nodeName == '#text'){⏎          // ignore empty text children⏎        } else if (child.nodeName == 'key'){⏎          key_name = PlistParser._textValue(child.firstChild);⏎        } else {⏎          key_value = parser._xml_to_json(child);⏎          dictionary[key_name] = key_value;⏎        }⏎      }⏎      return dictionary;⏎    case 'array':⏎      var standard_array = [];⏎      for(var i = 0; i < child_nodes.length; ++i){⏎        var child = child_nodes[i];⏎        standard_array.push(parser._xml_to_json(child));⏎      }⏎      return standard_array;⏎    case 'string':⏎      return PlistParser._textValue(parent_node);⏎    case 'date':⏎      var date = PlistParser._parseDate(PlistParser._textValue(parent_node));⏎      return date.toString();⏎    case 'integer':⏎    ⏎      // Second argument (radix parameter) forces string to be interpreted in base 10.⏎      return parseInt(PlistParser._textValue(parent_node), 10);⏎    case 'real':⏎    ⏎      return parseFloat(PlistParser._textValue(parent_node));⏎    case 'data':⏎      return PlistParser._textValue(parent_node);⏎    case 'true':⏎      return true;⏎    case 'false':⏎    ⏎      return false;⏎      ⏎    ⏎    case '#text':⏎      break;⏎  };⏎};⏎PlistParser._textValue = function(node) {⏎  if (node.text){⏎    return node.text;⏎  } else {⏎    return node.textContent;⏎  };⏎};⏎// Handle date parsing in non-FF browsers⏎// Thanks to http://www.west-wind.com/weblog/posts/729630.aspx⏎PlistParser._parseDate = function(date_string){⏎  var reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;⏎  var matched_date = reISO.exec(date_string);⏎  if (matched_date){ ⏎    return new Date(Date.UTC(+matched_date[1], +matched_date[2] - 1, +matched_date[3], +matched_date[4], +matched_date[5], +matched_date[6]));⏎  };⏎};⏎// Lifted (then modified) from: ⏎// http://blog.stchur.com/2007/04/06/serializing-objects-in-javascript/⏎PlistParser.serialize = function(_obj) {⏎  // Let Gecko browsers do this the easy way⏎  try{⏎    if (typeof _obj.toSource !== 'undefined' && typeof _obj.callee === 'undefined') {⏎      return _obj.toSource();⏎    }⏎  } catch(e) {⏎    // Keep on truckin'.⏎  }⏎  // Other browsers must do it the hard way⏎  switch (typeof _obj)⏎  {⏎    // numbers, booleans, and functions are trivial:⏎    // just return the object itself since its default .toString()⏎    // gives us exactly what we want⏎    case 'number':⏎    case 'boolean':⏎    case 'function':⏎      return _obj;⏎    // for JSON format, strings need to be wrapped in quotes⏎    case 'string':⏎      return '\'' + _obj + '\'';⏎    case 'object':⏎      var str;⏎      if (_obj.constructor === Array || typeof _obj.callee !== 'undefined')⏎      {⏎        str = '[';⏎        var i, len = _obj.length;⏎        for (i = 0; i < len-1; i++) { str += PlistParser.serialize(_obj[i]) + ','; }⏎        str += PlistParser.serialize(_obj[i]) + ']';⏎      }⏎      else⏎      {⏎        str = '{';⏎        var key;⏎        for (key in _obj) { ⏎          // "The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype."⏎          if (_obj.hasOwnProperty(key)) {⏎            str += key + ':' + PlistParser.serialize(_obj[key]) + ','; ⏎          };⏎        };⏎        str = str.replace(/\,$/, '') + '}';⏎      }⏎      return str;⏎    default:⏎      return 'UNKNOWN';⏎  };⏎};⏎PlistParser.toPlist = function(obj){⏎  var xml = '<?xml version="1.0" encoding="UTF-8"?>';⏎  xml += '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">';⏎  var container = document.createElement('xml');⏎  var plist = document.createElement('plist');⏎  plist.setAttribute('version','1.0');⏎  container.appendChild(plist);⏎  ⏎  var root = document.createElement('dict');⏎  plist.appendChild(root);⏎  var getISOString = function(date){⏎    function pad(n) { return n < 10 ? '0' + n : n }⏎    return date.getUTCFullYear() + '-'⏎      + pad(date.getUTCMonth() + 1) + '-'⏎      + pad(date.getUTCDate()) + 'T'⏎      + pad(date.getUTCHours()) + ':'⏎      + pad(date.getUTCMinutes()) + ':'⏎      + pad(date.getUTCSeconds()) + 'Z';⏎  }⏎  var walkObj = function(target, obj, callback){⏎    for(var i in obj){⏎      callback(target, i, obj[i]);⏎    }⏎  }⏎  var processObject = function(target, name, value){⏎    var key = document.createElement('key');⏎    key.innerHTML = name;⏎    target.appendChild(key);⏎    if(typeof value == 'object'){⏎      if(value instanceof Date){⏎        var date = document.createElement('date');⏎        date.innerHTML = getISOString(value);⏎        target.appendChild(date);⏎      }else{⏎        var dict = document.createElement('dict');⏎        walkObj(dict, value, processObject)⏎        target.appendChild(dict);⏎      }⏎    }else if(typeof value == 'boolean'){⏎      var bool = document.createElement(value.toString());⏎      target.appendChild(bool);⏎    }else{⏎      var string = document.createElement('string');⏎      string.innerHTML = value;⏎      target.appendChild(string);⏎    }⏎  };⏎  walkObj(root, obj, processObject);⏎  return xml+container.innerHTML;⏎};⏎)
44: 设定变量 (plistparser)
45: 文本 (<html>⏎<head>⏎<meta charset="utf-8">⏎<meta name="viewport" content="initial-scale=1, width=device-width">⏎<style>⏎body {⏎font-family: monospace;⏎white-space: pre;⏎}⏎</style>⏎</head>⏎<body>⏎<script>⏎⊲**plistparser**⊳⏎var wflow = ⊲**plist_escape**⊳;⏎var actionNamesTranslation = ⊲**action_names**⊳;⏎var allActionParams = ⊲**action_paras**⊳;⏎var variableOpeningChar = "⊲**var_ahead**⊳", variableClosingChar = "⊲**var_behind**⊳";⏎var deviceModel = "device";⏎⊲**script**⊳⏎</script>⏎</body>⏎</html>)
46: 设定名称 (action_list.html, with File Extension)
47: Base64 编码
48: URL (data:text/html;base64,⊲**Base64 Encoded**⊳)
49: 获取网页内容
50: 从输入中获取文本
51: 从输入中获取词典
52: 获取词典值 (Key: list)
53: 合并文本
54: 设定变量 (action_list)
55: 从输入中获取词典
56: 设定变量 (dict)
57: 获取词典值 (Key: WFActionTypes)
58: 为每个项目重复
59: 文本 (- ⊲**Repeat Item**⊳)
60: 添加到变量 (ActionTypes)
61 (58, ): 为每个项目重复
62: 获取词典值 (Key: WFWorkflowIcon)
63: 获取词典值 (Key: WFWorkflowIconGlyphNumber)
64: 获取词典值 (Key: WFWorkflowIcon)
65: 获取词典值 (Key: WFWorkflowIconStartColor)
66: 获取词典值 (Key: WFWorkflowTypes)
67: 获取词典值 (Key: WFWorkflowInputContentItemClasses)
68: 为每个项目重复
69: 文本 (⊲**Repeat Item**⊳)
70: 替换文本 (Replace WF with , Regex: No, Case Sensitive: Yes)
71: 替换文本 (Replace ContentItem with  , Regex: No, Case Sensitive: Yes)
72: 添加到变量 (Classes)
73 (68, ): 为每个项目重复
74: 合并文本 (Separator: ",")
75: 设定变量 (Classes)
76: 获取词典值 (Key: WFWorkflowActions)
77: 计数 (Items)
78: 获取词典值 (Key: WFWorkflowActions)
79: 为每个项目重复
80: 如果 (99 is.workflow.actions.runworkflow)
81: 获取词典值 (Key: WFWorkflowActionParameters)
82: 获取词典值 (Key: WFWorkflowName)
83: 文本 (- ⊲**Dictionary Value**⊳)
84: 添加到变量 (Dependencies)
85 (80, 99 is.wo...): 如果
86: 如果 (99 is.workflow.actions.comment)
87: 获取词典值 (Key: WFWorkflowActionParameters)
88: 获取词典值 (Key: WFCommentActionText)
89: 文本 (- ⊲**Dictionary Value**⊳)
90: 添加到变量 (Comments)
91 (86, 99 is.wo...): 如果
92 (86, 99 is.wo...): 如果
93 (80, 99 is.wo...): 如果
94 (79, ): 为每个项目重复
95: 匹配文本 (Case Sensitive: Yes, Pattern: b(https?|ftp|file)://S+)
96: 替换文本 (Replace </string> with , Regex: No, Case Sensitive: Yes)
97: 替换文本 (Replace http://www.apple.com/DTDs/PropertyList-1.0.dtd"> with , Regex: No, Case Sensitive: Yes)
98: 为每个项目重复
99: 文本 ( - ⊲**Repeat Item**⊳)
100: 添加到变量 (Urls)
101 (98, ): 为每个项目重复
102: 文本 (# ⊲**sc_name**⊳.⊲**file_ext**⊳⏎## 快捷指令信息⏎快捷指令：⊲**sc_name**⊳⏎动作数量：⊲**Count**⊳⏎文件大小：⊲**file_size**⊳⏎Glyph 编号 : ⊲**Dictionary Value**⊳⏎Glyph 颜色 : ⊲**Dictionary Value**⊳⏎快捷指令类型 : ⏎⊲**Dictionary Value**⊳⏎## 依赖 :⏎⊲**Dependencies**⊳⏎## URLs :⏎⊲**Urls**⊳⏎## 动作列表 : ⏎```⏎⊲**action_list**⊳⏎```⏎## Content Classes : ⏎⊲**Classes**⊳⏎## 注释:⏎```⏎⊲**Comments**⊳⏎```)
103: 设定变量 (result)
104: 从 Markdown 制作多信息文本
105: 用多信息文本制作 HTML
106: 如果 (99 shortcut)
107: 文本 (<!DOCTYPE html>⏎<html>⏎<head>⏎<title> ⊲**sc_name**⊳ - 🔬快捷指令分析工具</title>⏎    <meta charset="utf-8" />⏎    <meta name="viewport" content="width=device-width, initial-scale=1.0" />⏎    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css">⏎</head>⏎<body>⏎<table style="undefined;table-layout: fixed; width: 700px">⏎    <colgroup>⏎        <col style="width: 100px">⏎        <col style="width:  600px">⏎    </colgroup>⏎    <tr>⏎        <th>⏎            <h1>⏎            <img src="data:image/png;base64,⊲**Base64已编码内容**⊳"/>⏎            </h1>⏎        </th>⏎    </tr>⏎</table>⏎<div class="container">⏎    <p>⏎    ⊲**来自多信息文本的HTML**⊳⏎</div>⏎</body>⏎</html>)
108 (106, 99 short...): 如果
109: 文本 (<!DOCTYPE html>⏎<html>⏎<head>⏎<title> ⊲**sc_name**⊳ - 🔬快捷指令分析工具</title>⏎    <meta charset="utf-8" />⏎    <meta name="viewport" content="width=device-width, initial-scale=1.0" />⏎    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css">⏎</head>⏎<body>⏎<div class="container">⏎    <p>⏎    ⊲**来自多信息文本的HTML**⊳⏎</div>⏎</body>⏎</html>)
110 (106, 99 short...): 如果
111: 设定名称 (⊲**sc_name**⊳.html, with File Extension)
112: 设定变量 (result_html)
113: 显示网页
114: 从菜单中选取
115 (114, ): 从菜单中选取 (保存为 HTML)
116: 存储文件
117 (114, ): 从菜单中选取 (保存为 Markdown)
118: 从输入中获取文本
119: 设定名称 (⊲**sc_name**⊳.md, without File Extension)
120: 存储文件
121 (114, ): 从菜单中选取 (分析下一个快捷指令)
122: 运行快捷指令 (Workflow "🔬快捷指令分析工具", Don’t Show When Run)
123 (114, ): 从菜单中选取 (退出)
124: 退出快捷指令
125 (114, ): 从菜单中选取
```

## Content Classes : 

AppStoreApp ,Article ,Contact ,Date ,EmailAddress ,GenericFile ,Image ,iTunesProduct ,Location ,DCMapsLink ,AVAsset ,PDF ,PhoneNumber ,RichText ,SafariWebPage ,String ,URL 

## 注释:

```
- 
```